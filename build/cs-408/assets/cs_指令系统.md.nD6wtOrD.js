import{_ as t,c as e,o as n,a3 as l}from"./chunks/framework.D61v7-2O.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"cs/指令系统.md","filePath":"cs/指令系统.md"}'),d={name:"cs/指令系统.md"},r=l('<h2 id="指令系统" tabindex="-1">指令系统 <a class="header-anchor" href="#指令系统" aria-label="Permalink to &quot;指令系统&quot;">​</a></h2><h2 id="指令的寻址方式" tabindex="-1">指令的寻址方式 <a class="header-anchor" href="#指令的寻址方式" aria-label="Permalink to &quot;指令的寻址方式&quot;">​</a></h2><p>数据寻址方式对比：</p><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">有效地址</th><th style="text-align:center;">访存次数</th><th style="text-align:center;">优点</th></tr></thead><tbody><tr><td style="text-align:center;">隐含寻址</td><td style="text-align:center;">程序指定</td><td style="text-align:center;">0</td><td style="text-align:center;">有利于缩短指令字长</td></tr><tr><td style="text-align:center;">立即寻址</td><td style="text-align:center;">A即是操作数</td><td style="text-align:center;">0</td><td style="text-align:center;">指令执行阶段不访问主存，指令执行时间最短</td></tr><tr><td style="text-align:center;">直接寻址</td><td style="text-align:center;">EA = A</td><td style="text-align:center;">1</td><td style="text-align:center;">简单，指令执行阶段仅访问一次主存，不需专门计算操作数的地址</td></tr><tr><td style="text-align:center;">间接寻址</td><td style="text-align:center;">EA = (A)</td><td style="text-align:center;">2</td><td style="text-align:center;">可扩大寻址范围</td></tr><tr><td style="text-align:center;">寄存器寻址</td><td style="text-align:center;">EA = R</td><td style="text-align:center;">0</td><td style="text-align:center;">指令在执行阶段不访问主存，只访问寄存器，指令字短且执行速度快，支持向量/矩阵运算。</td></tr><tr><td style="text-align:center;">寄存器间接寻址</td><td style="text-align:center;">EA = (R)</td><td style="text-align:center;">1</td><td style="text-align:center;">与一般间接寻址相比速度更快</td></tr><tr><td style="text-align:center;">相对寻址</td><td style="text-align:center;">EA = (PC) + A</td><td style="text-align:center;">1</td><td style="text-align:center;">广泛应用于转移指令</td></tr><tr><td style="text-align:center;">基址寻址</td><td style="text-align:center;">EA = (BR) + A</td><td style="text-align:center;">1</td><td style="text-align:center;">便于程序“浮动”，方便实现多道程序并发运行</td></tr><tr><td style="text-align:center;">变址寻址</td><td style="text-align:center;">EA = (BR) + A</td><td style="text-align:center;">1</td><td style="text-align:center;">特别适合编制循环程序</td></tr></tbody></table><h2 id="程序的机器级代码表示" tabindex="-1">程序的机器级代码表示 <a class="header-anchor" href="#程序的机器级代码表示" aria-label="Permalink to &quot;程序的机器级代码表示&quot;">​</a></h2><h2 id="cisc和risc" tabindex="-1">CISC和RISC <a class="header-anchor" href="#cisc和risc" aria-label="Permalink to &quot;CISC和RISC&quot;">​</a></h2><p>CISC和RISC对比：</p><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">CISC</th><th style="text-align:center;">RISC</th></tr></thead><tbody><tr><td style="text-align:center;">指令系统规模</td><td style="text-align:center;">复杂，庞大</td><td style="text-align:center;">简单，精简</td></tr><tr><td style="text-align:center;">指令数目</td><td style="text-align:center;">一般多于200条</td><td style="text-align:center;">一般小于100条</td></tr><tr><td style="text-align:center;">指令字长</td><td style="text-align:center;">不固定</td><td style="text-align:center;">定长</td></tr><tr><td style="text-align:center;">访存指令</td><td style="text-align:center;">访存指令多</td><td style="text-align:center;">只有取数（Load）和存数（Store）指令</td></tr><tr><td style="text-align:center;">寄存器数目</td><td style="text-align:center;">较少</td><td style="text-align:center;">多</td></tr><tr><td style="text-align:center;">各种指令使用频度</td><td style="text-align:center;">相差很大</td><td style="text-align:center;">都比较常用</td></tr><tr><td style="text-align:center;">各种指令执行时间</td><td style="text-align:center;">相差较大</td><td style="text-align:center;">大部分指令在一个时钟周期内可以完成</td></tr><tr><td style="text-align:center;">目标代码</td><td style="text-align:center;">难以用优化编译生成高效的目标代码</td><td style="text-align:center;">采用用优化编译生成高效的目标代码</td></tr><tr><td style="text-align:center;">控制方式</td><td style="text-align:center;">微程序控制</td><td style="text-align:center;">组合逻辑控制</td></tr></tbody></table>',8),a=[r];function c(s,i,x,y,g,o){return n(),e("div",null,a)}const b=t(d,[["render",c]]);export{_ as __pageData,b as default};
